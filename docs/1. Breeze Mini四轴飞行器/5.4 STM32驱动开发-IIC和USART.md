title: 5.4 STM32驱动开发-IIC和USART

## 前言

讲解的这部分内容和代码在工程目录中的 **Drivers** 目录下的 **stm32f10x_driver_iic.c**、**stm32f10x_driver_iic.h**、**stm32f10x_driver_usart.c** 和 **stm32f10x_driver_usart.h** 中。

## IIC协议

### 简介

IIC即 **Inter-Integrated Circuit**(集成电路总线）是一种简单、双向、二线制同步串行总线，这种总线协议是由飞利浦半导体在八十年代初设计出来的。IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数种统一的通信标准，大家都按照这个标准在自家产品中去实现，这样就可以很方便地在各个产品中据传输的控制源。IIC总线协议简单来说就是为了解决各大厂商众多产品之间相互通信问题所提出的一传送数据了。

IIC总线由两根信号线组成，一个是双向数据线SDA，另一根线是时钟线SCL，所有接到IIC总线设备上上的串行数据SDA线都接到总线的SDA上，各个设备的时钟线SCL都接到总线的SCL上。IIC协议在 **Breeze Mini** 上主要用于读取支持IIC协议的MPU6050和HMC5883L传感器的数据。

### IIC操作

#### 1. 总线空闲

SCL高电平，SDA高电平

#### 2. 起始位

SCL高电平，SDA出现下降沿

![breeze_embedded_iic_startbit](https://microdynamics-1256406063.cos.ap-shanghai.myqcloud.com/breeze/embedded/iic_startbit.png)

#### 3. 终止位

SCL高电平，SDA出现上升沿

![breeze_embedded_iic_endbit](https://microdynamics-1256406063.cos.ap-shanghai.myqcloud.com/breeze/embedded/iic_endbit.png)

#### 4. 数据传输

SCL低电平时SDA的高低电平变化，且SDA在SCL为高电平时不变换(因为此时SDA的状态挥别写入从机)

![breeze_embedded_iic_databits](https://microdynamics-1256406063.cos.ap-shanghai.myqcloud.com/breeze/embedded/iic_databits.png)

IIC的时钟线SCL最高频率：400K

应答：当IIC主机(可以是发送者也可以是接受者)将8位命令或数据传送出去后，会将SDA信号线设置为输入，并等待从机应答(等待SDA由高电平跳变为低电平)，若从机应答正确，则表明命令或数据传送成功，否则传送失败。**注意应答信号总是由数据接收方发给数据发送方的**。

IIC器件地址：每个支持IIC的外部器件都有一个IIC总线器件地址，这些器件地址有的在出厂时就已经设定好了，有的是只有部分位已经确定，未确定位可以通过在硬件设计上拉低或高某个管脚的电平来设置。比如EEPROM的前四位地址已经确定为1010，后三个地址则可以设置，这样在一个IIC总线上就可以支持最多挂载8个EEPROM。

#### 5. 传送包结构

以下是IIC总线协议传送的包结构图：

![breeze_embedded_iic_package_structure](https://microdynamics-1256406063.cos.ap-shanghai.myqcloud.com/breeze/embedded/iic_package_structure.png)


上图中开始信号之后的7位地址表示器件地址，第8位表示主机读或写位，0为写，1为读，接着是响应位。

#### 6. 字节读写时序

IIC器件单字节写时序为：

![breeze_embedded_iic_single_data_write](https://microdynamics-1256406063.cos.ap-shanghai.myqcloud.com/breeze/embedded/iic_single_data_write.png)

IIC器件的多字节写时序：

![breeze_embedded_iic_multi_data_write](https://microdynamics-1256406063.cos.ap-shanghai.myqcloud.com/breeze/embedded/iic_multi_data_write.png)

IIC器件单字节读时序(注意最后产生无应答信号)：

![breeze_embedded_iic_single_data_read](https://microdynamics-1256406063.cos.ap-shanghai.myqcloud.com/breeze/embedded/iic_single_data_read.png)

### 硬件连接

IIC属于 **Breeze Mini** 主微控制器STM32F103TBU6的通信协议实现，是没有外部电路连接的。

### 软件设计

虽然STM32F103TBU6也提供IIC总线的外设接口，可以直接通过官方提供的固件库实现IIC协议，但是由于STM32F103系列的IIC外设接口使用起来不是很稳定，所以飞控代码中是直接通过端口高低电平操作和延时函数来模拟实现IIC协议的。整个代码比较好理解，可以看做是用C语言对上述协议"翻译"了一遍，所以读者可以依照上述协议来对照地理解代码。因为这部分代码比较简单，所以只简单介绍一下初始化函数。完整代码在工程目录下的 **Drivers** 子目录下的 **stm32f10x_driver_iic.c** 和 **stm32f10x_driver_iic.h** 中。

#### IIC端口初始化

```c
void IIC_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
}
```

由于是用GPIO端口模拟实现的IIC协议，即 **按照高低电平和相应时序操作GPIO端口**。所以这部分初始化代码和初始化LED部分(同样也是GPIO端口操作)是一样的，只不过这里初始化的端口是 **PB6** 和 **PB7**。

下面的代码是所实现的IIC端口操作的全部接口：

```c
extern void IIC_Init(void);
extern void IIC_SendAckSignal(void);
extern void IIC_SendStartSignal(void);
extern void IIC_SendStopSignal(void);
extern void IIC_SendNAckSignal(void);
extern void IIC_WaitAckSignal(void);
extern u8   IIC_ReadByte(u8 iic_addr, u8 reg_addr);
extern u8   IIC_ReadBytes(u8 dev_addr, u8 reg_addr, u8 byte_nums, u8 *data);
extern u8   IIC_ReadOneByte(u8 ack);
extern u8   IIC_WriteBit(u8 dev_addr, u8 reg_addr, u8 bit_index, u8 data);
extern u8   IIC_WriteBits(u8 dev_addr, u8 reg_addr, u8 bit_start, u8 bit_len,
                          u8 data);
extern u8   IIC_WriteByte(u8 dev_addr, u8 reg_addr, u8 data);
extern u8   IIC_WriteBytes(u8 dev_addr, u8 reg_addr, u8 byte_nums, u8 *data);
extern u8   IIC_WriteOneByte(u8 byte);
```

其中如下函数是基础功能函数，用来实现IIC协议的基础操作：

```c
extern void IIC_Init(void);
extern void IIC_SendAckSignal(void);
extern void IIC_SendStartSignal(void);
extern void IIC_SendStopSignal(void);
extern void IIC_SendNAckSignal(void);
extern void IIC_WaitAckSignal(void);
```

而后面的函数则使用IIC操作来读写寄存器的内容。这里就不再一一介绍了。

## USART

### 简介

USART即 **Universal Synchronous Asynchronous Receiver/Transmitter**(通用同步异步串行接收/发送器)，这个同步和异步指的是通信的双方的时钟信号是否相同的，如果是相同的话则就是工作在同步模式，否则就是工作在异步模式，同步模式一般都是要求通信双方保持同步时钟序，这也是因为同步通信数据是以一组约定好的字符格式来为定义的，简单来讲同步串口通信传输不以单个字符为基本单位，而是以一个字符组合(帧)，帧的长度和数据内容由开发者定义，这个帧中包含有同步信息以通知接收方调整时序进而达到同步，由于数据是以一种包的形式发送的，如果发送和接收方时钟不同步的话，则接收方可能不会从包的起始开始接收，出现错误。而异步通信是以单个字符作为传输的基本单位的，但是为了接收方能够知道数据接收的起始和验证数据在传输过程中没有错误，还需要人为在数据间插入起始位、终止位和校验位。STM32TBU6支持的USART在实际开发过程中主要是和PC，nRF51822进行通信，通信双方的时钟序是不同的，所以目前使用的是 **异步串口** 进行通信。


### 固件库操作

### 硬件连接

USART属于 **Breeze Mini** 主微控制器STM32F103TBU6的通信协议实现，是没有外部电路连接的。

### 软件设计

#### 环形收发队列

#### 初始化

## 总结

## 参考

* [STM32开发指南-库函数版本_V3.1.pdf](https://documents-1256406063.cos.ap-shanghai.myqcloud.com/STM32F1%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88%E6%9C%AC_V3.1%20.pdf), 正点原子, [ALLENTEK](http://www.alientek.com/).

* [IIC协议](https://www.cnblogs.com/bixiaopengblog/p/7469536.html)

* [同步串口和一步串口的区别及使用情况](https://blog.csdn.net/seashine_yan/article/details/71192283)